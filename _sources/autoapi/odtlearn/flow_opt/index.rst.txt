:py:mod:`odtlearn.flow_opt`
===========================

.. py:module:: odtlearn.flow_opt


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   odtlearn.flow_opt.FlowOPT_IPW
   odtlearn.flow_opt.FlowOPT_DM
   odtlearn.flow_opt.FlowOPT_DR




.. py:class:: FlowOPT_IPW(solver, depth=1, time_limit=60, num_threads=None, verbose=False)


   Bases: :py:obj:`odtlearn.flow_opt_ss.FlowOPTSingleSink`

   
   A user-facing class for learning optimal prescriptive trees with inverse probability weighting (IPW) objective.


   :Parameters:

       **solver** : str, default="gurobi"
           The solver to use for the optimization problem. Can be either "gurobi" or "cbc".

       **depth** : int
           The maximum depth of the tree to be learned.

       **time_limit** : int, default=300
           The time limit (in seconds) for solving the optimization problem.

       **num_threads** : int, default=1
           The number of threads to use for solving the optimization problem.

       **verbose** : bool, default=False
           Whether to print verbose output during the tree learning process.









   .. rubric:: Notes

   This class inherits from the :mod:`FlowOPTSingleSink <odtlearn.flow_opt_ss.FlowOPTSingleSink>` class
   and provides a user-friendly interface
   for learning optimal prescriptive trees with inverse probability weighting (IPW) objective.

   The IPW objective is used to account for potential confounding factors in observational data
   and to estimate the causal effect of treatments on outcomes. The inverse probability weights
   are computed based on the propensity scores of receiving each treatment given the observed covariates.

   The class extends the functionality of :mod:`FlowOPTSingleSink <odtlearn.flow_opt_ss.FlowOPTSingleSink>` by adding
   the `_ipw` attribute to store
   the inverse probability weights and overriding the :meth:`fit <odtlearn.flow_opt.FlowOPT_IPW.fit>` method to
   accept the IPW as an additional argument.

   The :meth:`_define_objective <odtlearn.flow_opt.FlowOPT_IPW._define_objective>` method is implemented to define
   the IPW objective function for the optimization problem.
   The objective maximizes the weighted sum of outcomes, where the weights are the product of the IPW and the
   treatment assignments.

   The class inherits the :meth:`predict <odtlearn.opt_pt.OptimalPrescriptiveTree.predict>`,
   :meth:`print_tree <odtlearn.opt_pt.OptimalPrescriptiveTree.print_tree>`,
   and :meth:`plot_tree <odtlearn.opt_pt.OptimalPrescriptiveTree.plot_tree>` methods from the
   :mod:`OptimalPrescriptiveTree <odtlearn.opt_pt.OptimalPrescriptiveTree>`
   class to make predictions and visualize the learned tree.

   Example usage:

   ```

   # Create an instance of FlowOPT_IPW
   opt_tree = FlowOPT_IPW(depth=3, time_limit=600, verbose=True)

   # Fit the optimal prescriptive tree using data and IPW
   opt_tree.fit(X, y, t, ipw)

   # Make predictions
   predictions = opt_tree.predict(X_new)

   # Plot the learned tree
   opt_tree.plot_tree()

   ```



   :Attributes:

       **_ipw** : :class:`numpy.ndarray`
           The inverse probability weights for each datapoint.

   .. rubric:: Methods



   =======================  ==========
     **fit(X, y, t, ipw)**  Fit the optimal prescriptive tree using the provided data and inverse probability weights.  
   **_define_objective()**  Define the objective function for the optimization problem.  
   =======================  ==========

   ..
       !! processed by numpydoc !!
   .. py:method:: fit(X, t, y, ipw)

      
      Fit the FlowOPT_IPW model to the given training data.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              The training input samples. Each feature should be binary (0 or 1).

          **t** : array-like of shape (n_samples,)
              The treatment values. An array of integers representing the treatment applied to each sample.

          **y** : array-like of shape (n_samples,)
              The observed outcomes upon given treatment t. An array of numbers representing the outcome for each sample.

          **ipw** : array-like of shape (n_samples,)
              The inverse propensity weights. An array of floats in the range (0, 1].

      :Returns:

          **self** : object
              Returns self.




      :Raises:

          ValueError
              If X contains non-binary values, or if X, t, y, and ipw have inconsistent numbers of samples.

          AssertionError
              If ipw contains values outside the range (0, 1].




      .. rubric:: Notes

      This method fits the FlowOPT_IPW model using the inverse probability weighting (IPW) approach.
      It sets up the optimization problem, solves it, and stores the results.
      The IPW approach is used to account for confounding in observational data.


      .. rubric:: Examples

      >>> from odtlearn.flow_opt import FlowOPT_IPW
      >>> import numpy as np
      >>> X = np.array([[0, 0], [1, 1], [1, 0], [0, 1]])
      >>> t = np.array([0, 1, 1, 0])
      >>> y = np.array([0.5, 1.2, 0.8, 0.3])
      >>> ipw = np.array([0.8, 0.7, 0.9, 0.6])
      >>> opt = FlowOPT_IPW(depth=2, time_limit=60)
      >>> opt.fit(X, t, y, ipw)



      ..
          !! processed by numpydoc !!

   .. py:method:: predict(X)

      
      Predict optimal treatments for samples in X using the fitted FlowOPT_IPW model.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              The input samples for which to make predictions. Each feature should be binary (0 or 1).

      :Returns:

          **t_pred** : ndarray of shape (n_samples,)
              The predicted optimal treatment for each sample in X.




      :Raises:

          NotFittedError
              If the model has not been fitted yet.

          ValueError
              If X contains non-binary values or has a different number of features than the training data.




      .. rubric:: Notes

      This method uses the prescriptive tree learned during the fit process to recommend treatments for new samples.
      It traverses the tree for each sample in X, following the branching decisions until reaching a leaf node,
      and returns the corresponding treatment recommendation.


      .. rubric:: Examples

      >>> from odtlearn.flow_opt import FlowOPT_IPW
      >>> import numpy as np
      >>> X_train = np.array([[0, 0], [1, 1], [1, 0], [0, 1]])
      >>> t_train = np.array([0, 1, 1, 0])
      >>> y_train = np.array([0.5, 1.2, 0.8, 0.3])
      >>> ipw_train = np.array([0.8, 0.7, 0.9, 0.6])
      >>> opt = FlowOPT_IPW(depth=2)
      >>> opt.fit(X_train, t_train, y_train, ipw_train)
      >>> X_test = np.array([[1, 1], [0, 0]])
      >>> t_pred = opt.predict(X_test)
      >>> print(t_pred)
      [1 0]



      ..
          !! processed by numpydoc !!


.. py:class:: FlowOPT_DM(solver, depth=1, time_limit=60, num_threads=None, verbose=False)


   Bases: :py:obj:`odtlearn.flow_opt_ms.FlowOPTMultipleSink`

   
   A user-facing class for learning optimal prescriptive trees with direct method (DM) objective.


   :Parameters:

       **solver** : str, default="gurobi"
           The solver to use for the optimization problem. Can be either "gurobi" or "cbc".
           If the CBC binaries are not found, Gurobi will be used by default.

       **depth** : int, default=1
           The maximum depth of the tree to be learned.

       **time_limit** : int, default=60
           The time limit (in seconds) for solving the optimization problem.

       **num_threads** : int, default=None
           The number of threads the solver should use. If not specified,
           the solver uses all available threads.

       **verbose** : bool, default=False
           Whether to print verbose output during the tree learning process.









   .. rubric:: Notes

   This class inherits from the :mod:`FlowOPTMultipleSink <odtlearn.flow_opt_ms.FlowOPTMultipleSink>` class
   and provides a user-friendly interface
   for learning optimal prescriptive trees with the direct method (DM) objective.

   The DM objective aims to maximize the expected outcome by directly using the counterfactual
   predictions (y_hat) for each treatment option. The counterfactual predictions represent the
   estimated outcomes for each individual under different treatment scenarios.

   The class extends the functionality of
   :mod:`FlowOPTMultipleSink <odtlearn.flow_opt_ms.FlowOPTMultipleSink>` by overriding
   the :meth:`fit <odtlearn.flow_opt.FlowOPT_DM.fit>` method to
   accept the counterfactual predictions (y_hat) as an additional argument.

   The :meth:`_define_objective <odtlearn.flow_opt.FlowOPT_DM._define_objective>` method is implemented to
   define the DM objective function for the
   optimization problem. The objective maximizes the sum of the counterfactual predictions weighted
   by the treatment assignments.

   Example usage:
   ```python
   # Create an instance of FlowOPT_DM
   opt_tree = FlowOPT_DM(depth=3, time_limit=600, verbose=True)

   # Fit the optimal prescriptive tree using data and counterfactual predictions
   opt_tree.fit(X, t, y, y_hat)

   # Make treatment recommendations
   recommendations = opt_tree.predict(X_new)
   ```




   .. rubric:: Methods



   =======================  ==========
   **fit(X, t, y, y_hat)**  Fit the optimal prescriptive tree using the provided data and counterfactual predictions.  
            **predict(X)**  Make treatment recommendations for the given input samples.  
   **_define_objective()**  Define the objective function for the optimization problem.  
   =======================  ==========

   ..
       !! processed by numpydoc !!
   .. py:method:: fit(X, t, y, y_hat)

      
      Fit the FlowOPT_DM model to the given training data.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              The training input samples. Each feature should be binary (0 or 1).

          **t** : array-like of shape (n_samples,)
              The treatment values. An array of integers representing the treatment applied to each sample.

          **y** : array-like of shape (n_samples,)
              The observed outcomes upon given treatment t. An array of numbers representing the outcome for each sample.

          **y_hat** : array-like of shape (n_samples, n_treatments)
              The counterfactual predictions. A 2D array where each row represents a sample and each column
              represents the predicted outcome for a specific treatment.

      :Returns:

          **self** : object
              Returns self.




      :Raises:

          ValueError
              If X contains non-binary values, or if X, t, y, and y_hat have inconsistent numbers of samples.

          AssertionError
              If y_hat doesn't have the correct shape based on the number of treatments.




      .. rubric:: Notes

      This method fits the FlowOPT_DM model using the direct method (DM) approach.
      It sets up the optimization problem, solves it, and stores the results.
      The DM approach uses counterfactual predictions to estimate treatment effects.


      .. rubric:: Examples

      >>> from odtlearn.flow_opt import FlowOPT_DM
      >>> import numpy as np
      >>> X = np.array([[0, 0], [1, 1], [1, 0], [0, 1]])
      >>> t = np.array([0, 1, 1, 0])
      >>> y = np.array([0.5, 1.2, 0.8, 0.3])
      >>> y_hat = np.array([[0.4, 0.6], [1.1, 1.3], [0.7, 0.9], [0.2, 0.4]])
      >>> opt = FlowOPT_DM(depth=2, time_limit=60)
      >>> opt.fit(X, t, y, y_hat)



      ..
          !! processed by numpydoc !!

   .. py:method:: predict(X)

      
      Predict optimal treatments for samples in X using the fitted FlowOPT_DM model.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              The input samples for which to make predictions. Each feature should be binary (0 or 1).

      :Returns:

          **t_pred** : ndarray of shape (n_samples,)
              The predicted optimal treatment for each sample in X.




      :Raises:

          NotFittedError
              If the model has not been fitted yet.

          ValueError
              If X contains non-binary values or has a different number of features than the training data.




      .. rubric:: Notes

      This method uses the prescriptive tree learned during the fit process to recommend treatments for new samples.
      It traverses the tree for each sample in X, following the branching decisions until reaching a leaf node,
      and returns the corresponding treatment recommendation.


      .. rubric:: Examples

      >>> from odtlearn.flow_opt import FlowOPT_DM
      >>> import numpy as np
      >>> X_train = np.array([[0, 0], [1, 1], [1, 0], [0, 1]])
      >>> t_train = np.array([0, 1, 1, 0])
      >>> y_train = np.array([0.5, 1.2, 0.8, 0.3])
      >>> y_hat_train = np.array([[0.4, 0.6], [1.1, 1.3], [0.7, 0.9], [0.2, 0.4]])
      >>> opt = FlowOPT_DM(depth=2)
      >>> opt.fit(X_train, t_train, y_train, y_hat_train)
      >>> X_test = np.array([[1, 1], [0, 0]])
      >>> t_pred = opt.predict(X_test)
      >>> print(t_pred)
      [1 0]



      ..
          !! processed by numpydoc !!


.. py:class:: FlowOPT_DR(solver, depth=1, time_limit=60, num_threads=None, verbose=False)


   Bases: :py:obj:`odtlearn.flow_opt_ms.FlowOPTMultipleSink`

   
   A user-facing class for learning optimal prescriptive trees with doubly robust (DR) objective.


   :Parameters:

       **solver** : str, default="gurobi"
           The solver to use for the optimization problem. Can be either "gurobi" or "cbc".
           If the CBC binaries are not found, Gurobi will be used by default.

       **depth** : int, default=1
           The maximum depth of the tree to be learned.

       **time_limit** : int, default=60
           The time limit (in seconds) for solving the optimization problem.

       **num_threads** : int, default=None
           The number of threads the solver should use. If not specified,
           the solver uses all available threads.

       **verbose** : bool, default=False
           Whether to print verbose output during the tree learning process.









   .. rubric:: Notes

   This class inherits from the :mod:`FlowOPTMultipleSink <odtlearn.flow_opt_ms.FlowOPTMultipleSink>` class
   and provides a user-friendly interface
   for learning optimal prescriptive trees with the doubly robust (DR) objective.

   The DR objective combines the inverse probability weighting (IPW) and the direct method (DM)
   to obtain a more robust estimate of the treatment effect. It utilizes both the observed outcomes
   and the counterfactual predictions, along with the inverse propensity weights.

   The class extends the functionality of :mod:`FlowOPTMultipleSink <odtlearn.flow_opt_ms.FlowOPTMultipleSink>`
   by overriding the :meth:`fit <odtlearn.flow_opt.FlowOPT_DR.fit>` method to
   accept the inverse propensity weights (ipw) and counterfactual predictions (y_hat) as additional
   arguments.

   The :meth:`_define_objective <odtlearn.flow_opt.FlowOPT_DR._define_objective>` method is implemented to define
   the DR objective function for the
   optimization problem. The objective maximizes the sum of the counterfactual predictions weighted
   by the treatment assignments, plus an additional term that adjusts for the difference between the
   observed outcomes and the counterfactual predictions, weighted by the inverse propensity weights.

   Example usage:
   ```python
   # Create an instance of FlowOPT_DR
   opt_tree = FlowOPT_DR(depth=3, time_limit=600, verbose=True)

   # Fit the optimal prescriptive tree using data, inverse propensity weights, and counterfactual predictions
   opt_tree.fit(X, t, y, ipw, y_hat)

   # Make treatment recommendations
   recommendations = opt_tree.predict(X_new)
   ```




   .. rubric:: Methods



   ============================  ==========
   **fit(X, t, y, ipw, y_hat)**  Fit the optimal prescriptive tree using the provided data, inverse propensity weights, and counterfactual predictions.  
                 **predict(X)**  Make treatment recommendations for the given input samples.  
        **_define_objective()**  Define the objective function for the optimization problem.  
   ============================  ==========

   ..
       !! processed by numpydoc !!
   .. py:method:: fit(X, t, y, ipw, y_hat)

      
      Fit the FlowOPT_DR model to the given training data.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              The training input samples. Each feature should be binary (0 or 1).

          **t** : array-like of shape (n_samples,)
              The treatment values. An array of integers representing the treatment applied to each sample.

          **y** : array-like of shape (n_samples,)
              The observed outcomes upon given treatment t. An array of numbers representing the outcome for each sample.

          **ipw** : array-like of shape (n_samples,)
              The inverse propensity weights. An array of floats in the range (0, 1].

          **y_hat** : array-like of shape (n_samples, n_treatments)
              The counterfactual predictions. A 2D array where each row represents a sample and each column
              represents the predicted outcome for a specific treatment.

      :Returns:

          **self** : object
              Returns self.




      :Raises:

          ValueError
              If X contains non-binary values, or if X, t, y, ipw, and y_hat have inconsistent numbers of samples.

          AssertionError
              If ipw contains values outside the range (0, 1] or if y_hat doesn't have the correct shape.




      .. rubric:: Notes

      This method fits the FlowOPT_DR model using the doubly robust (DR) approach.
      It sets up the optimization problem, solves it, and stores the results.
      The DR approach combines the inverse probability weighting and direct method approaches
      to provide more robust estimates of treatment effects.


      .. rubric:: Examples

      >>> from odtlearn.flow_opt import FlowOPT_DR
      >>> import numpy as np
      >>> X = np.array([[0, 0], [1, 1], [1, 0], [0, 1]])
      >>> t = np.array([0, 1, 1, 0])
      >>> y = np.array([0.5, 1.2, 0.8, 0.3])
      >>> ipw = np.array([0.8, 0.7, 0.9, 0.6])
      >>> y_hat = np.array([[0.4, 0.6], [1.1, 1.3], [0.7, 0.9], [0.2, 0.4]])
      >>> opt = FlowOPT_DR(depth=2, time_limit=60)
      >>> opt.fit(X, t, y, ipw, y_hat)



      ..
          !! processed by numpydoc !!

   .. py:method:: predict(X)

      
      Predict optimal treatments for samples in X using the fitted FlowOPT_DR model.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              The input samples for which to make predictions. Each feature should be binary (0 or 1).

      :Returns:

          **t_pred** : ndarray of shape (n_samples,)
              The predicted optimal treatment for each sample in X.




      :Raises:

          NotFittedError
              If the model has not been fitted yet.

          ValueError
              If X contains non-binary values or has a different number of features than the training data.




      .. rubric:: Notes

      This method uses the prescriptive tree learned during the fit process to recommend treatments for new samples.
      It traverses the tree for each sample in X, following the branching decisions until reaching a leaf node,
      and returns the corresponding treatment recommendation.


      .. rubric:: Examples

      >>> from odtlearn.flow_opt import FlowOPT_DR
      >>> import numpy as np
      >>> X_train = np.array([[0, 0], [1, 1], [1, 0], [0, 1]])
      >>> t_train = np.array([0, 1, 1, 0])
      >>> y_train = np.array([0.5, 1.2, 0.8, 0.3])
      >>> ipw_train = np.array([0.8, 0.7, 0.9, 0.6])
      >>> y_hat_train = np.array([[0.4, 0.6], [1.1, 1.3], [0.7, 0.9], [0.2, 0.4]])
      >>> opt = FlowOPT_DR(depth=2)
      >>> opt.fit(X_train, t_train, y_train, ipw_train, y_hat_train)
      >>> X_test = np.array([[1, 1], [0, 0]])
      >>> t_pred = opt.predict(X_test)
      >>> print(t_pred)
      [1 0]



      ..
          !! processed by numpydoc !!


